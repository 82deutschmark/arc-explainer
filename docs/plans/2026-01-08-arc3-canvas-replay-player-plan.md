## 2026-01-08 – ARC-3 Canvas Replay Player Plan

### 1. Context & Problem
- Landing page currently embeds pre-rendered MP4 clips generated by `scripts/arc3/generate_arc3_video.py`.
- JSONL replay sources only include sparse key frames, so generated MP4s miss interpolated animation states (e.g., SP80 purple stream, AS66 box slides).
- Maintaining/hosting MP4s is brittle, bandwidth-heavy, and prevents interactive controls.
- Need to adopt the Canvas-driven playback approach described in `docs/ARC3_CANVAS_REPLAY_PLAYER.md`.

### 2. Objectives
1. Deliver a reusable React Canvas player that renders ARC-3 JSONL replays with tweened frames at ~5 fps using the canonical palette from `shared/config/arc3Colors.ts`.
2. Replace the landing page’s `<video>` showcase with the new Canvas player, loading from local JSONL assets.
3. Preserve accessibility (reduced motion, keyboard navigation) and add essential playback controls (play/pause, seek, speed presets).
4. Document behavior (guide + plan status) and prep deprecation path for the legacy MP4 pipeline.

### 3. Deliverables
- `client/src/components/ARC3CanvasPlayer.tsx` (or equivalent) with file header metadata, hooks for playback, interpolation logic, and controls.
- Updated `client/src/pages/LandingPage.tsx` to consume JSONL game data via the new component instead of looping MP4s.
- Possible helper for parsing JSONL (utility or hook) if existing helpers don’t exist—must respect SRP/DRY.
- Documentation/CHANGELOG updates capturing the move from MP4s to Canvas playback.

### 4. Implementation Approach
1. **Replay Data Loading**
   - Confirm JSONL asset location (e.g., `/public/replays/*.jsonl` or `arc3/*.jsonl`).
   - Build a small parser that streams/reads JSONL text, returning an array of `{ timestampMs, grid }` frames.
   - Normalize grid dimensions and color codes (map through `arc3Colors` for fill styles).

2. **Canvas Rendering Engine**
   - Create a React component that owns:
     - `<canvas>` ref sized responsively (default 512–768 px square) with devicePixelRatio scaling.
     - Playback state: `currentFrameIdx`, `tweenProgress`, `isPlaying`, `speed`, `scrubPercentage`.
     - Animation loop via `requestAnimationFrame`, ticking every ~200ms / speed multiplier.
   - Implement interpolation:
     - Given `frameA`, `frameB`, compute normalized progress.
     - For each cell, blend colors if value changes; otherwise reuse previous color.
     - Optionally fade cells by drawing two rectangles with alpha weights (simple crossfade).

3. **UI & Controls**
   - Provide play/pause, step-back/forward, range input slider, and speed selector (0.5×, 1×, 2×).
   - Respect `prefers-reduced-motion`: auto-pause and allow manual play.
   - Add minimal metadata (game ID, informal title) around the canvas; keep styling consistent with current landing hero aesthetic.

4. **Landing Page Integration**
   - Replace the `<video>` region with the new component.
   - Determine rotation strategy: either preload multiple JSONL files and rotate, or allow manual selection (initial scope: maintain current auto-rotation, switching dataset + resetting playback).
   - Ensure prefetching of next replay to avoid blank screens.

5. **Testing & Verification**
   - Manual QA on `sp80-test3.jsonl`, `as66-test1.jsonl`, and at least one additional game (ls20 or ft09).
   - Verify interpolation smoothness, controls, reduced-motion behavior, and mobile responsiveness.
   - Update docs/CHANGELOG to capture completion and mark this plan done.

### 5. Risks & Mitigations
- **Large JSONL payloads**: implement lazy loading or streaming parsing to avoid blocking render; fallback to spinner while fetching.
- **Color fidelity**: reuse shared palette module to avoid drift.
- **Animation timing drift**: drive loop via timestamps rather than frame count to keep speed consistent across browsers.

### 6. Exit Criteria
- Landing page showcases ARC-3 games via Canvas with smooth animations, no MP4 dependencies.
- Plan marked complete in docs; CHANGELOG entry recorded with summary of what/why/how.
