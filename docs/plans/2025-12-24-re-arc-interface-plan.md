# RE-ARC Dataset Generation & Verification Interface

**Author:** Claude Code using Sonnet 4.5
**Date:** 2025-12-24
**Purpose:** Plan for implementing a stateless RE-ARC dataset generation and verification interface

## Overview

Create a web interface that allows users to:
1. Generate RE-ARC datasets on demand
2. Submit solutions for verification
3. Verification works via XOR of task IDs to regenerate the seed (stateless, no DB needed)

## Data Structures

```typescript
type Task = {
  train: { input: number[][]; output: number[][] }[];
  test: { input: number[][]; output?: number[][] }[];
};

type Dataset = {
  [taskId: string]: Task;
};

type Submission = {
  [taskId: string]: {
    attempt_1: number[][];
    attempt_2: number[][];
  }[];
};
```

## High-Level Approach

### Generation Flow
1. User requests dataset generation
2. Backend immediately starts HTTP response with download headers
3. Backend streams JSON incrementally as tasks are generated
4. Client receives streaming download (~10 seconds total)
5. File download completes when all tasks generated

### Verification Flow
1. User uploads submission JSON
2. Validate submission structure
3. Extract task IDs, XOR to recover seed
4. Decode generation timestamp from task IDs in order generated by seed
5. Regenerate dataset deterministically
6. Compare submission attempts to ground truth
7. Return score + time elapsed (submission time - generation time)

### Components

- reArcController: /generate (streaming download) and /verify (SSE streaming) endpoints
- reArcService: orchestrate Python re-arc library calls
- reArcSeed utils: XOR logic and message encoding/decoding

## Backend Patterns (from existing codebase)

**Controllers:**
- Export functions wrapped with `asyncHandler` middleware
- Use `formatResponse` utility for consistent responses
- Import from services, don't do DB queries directly

**Services:**
- Orchestrate Python subprocess calls via `child_process.spawn`
- Handle stdout/stderr streaming for progress updates
- For /generate: Stream JSON chunks directly to HTTP response as tasks complete

## Implementation Steps

### Phase 1: Setup & Install
- [ ] Clone re-arc library from GitHub
- [ ] Review re-arc library (lib.py)
- [ ] Install `express-rate-limit` for API rate limiting

### Phase 2: Core Infrastructure
- [ ] Create type definitions in `shared/types.ts`
- [ ] Implement XOR seed logic in `server/utils/reArcSeed.ts`
- [ ] Write tests for XOR seed logic (`tests/reArcSeed.test.ts`)
- [ ] Write integration tests (`tests/reArcService.test.ts`)

### Phase 3: Backend API
- [ ] Create `reArcController.ts` with generation endpoint
- [ ] Create verification endpoint
- [ ] Add routes to `server/routes.ts` (follow existing pattern)
- [ ] Write endpoint tests (`tests/reArcController.test.ts`)
- [ ] Add error handling and validation

---

**Frontend implementation:** See `2025-12-24-rearc-frontend-design.md`

## Key Technical Details

### XOR Seed Recovery & Steganographic Encoding
**Task IDs:** 8 hex chars (32 bits)
- Upper 16 bits: unique random from PRNG(seed) - acts as position identifier
- Lower 16 bits: random from PRNG, optionally XOR'd with message bytes

**Seed recovery:** `XOR(all_task_ids) = seed` (order-independent)

**Steganographic message encoding:**
- XOR arbitrary message bytes into lower 16 bits of task IDs in seed order
- Decode: regenerate PRNG, match upper 16 bits to find generation order, XOR lower bits back
- Submission order doesn't matter - upper bits identify which task was at each generation position
- Looks like random noise without seed
- Max message: `(n_tasks - 1) * 2` bytes

**Current encoded message format:**
- Version: 1 byte (value = 0)
- Generation timestamp: 4 bytes (Unix seconds, big-endian)
- Total: 5 bytes
- (Format may change in future versions)

### Scoring
- Each task worth 1.0 point, divided equally across its test pairs
- Test pair solved if ANY of 2 attempts correct
- Overall score = (sum of task scores) / (total tasks)

## Files to Create

**Backend:**
```
server/
├── controllers/reArcController.ts
├── services/reArc/
│   └── reArcService.ts
├── utils/reArcSeed.ts
└── routes.ts (add routes)
```

**Tests:**
```
tests/
├── reArcSeed.test.ts          # XOR logic, message encoding
├── reArcService.test.ts       # Python integration, generation
└── reArcController.test.ts    # API endpoints
```

**Types:**
```
shared/types.ts (add ReArc types)
```

## API

**Generation endpoint:** `POST /api/rearc-eval/generate` (Streaming Download)
- No parameters
- Returns chunked HTTP response with headers:
  - `Content-Type: application/json`
  - `Content-Disposition: attachment; filename="rearc-dataset-{timestamp}.json"`
  - `Transfer-Encoding: chunked`
- Response body: JSON object streamed incrementally as tasks are generated
- Format: Valid JSON object `{ "taskId1": {...}, "taskId2": {...}, ... }`
- Each task contains training pairs (input+output) and test pairs (input only; ground truth reserved for verification)
- Tasks stream in real-time (~10 seconds for full dataset)
- On error: Returns 500 with error JSON instead of download

**Verification endpoint:** `POST /api/rearc-eval/verify` (SSE stream)
- Body: `{ submission: Submission }`
- Client-side validation before upload:
  - JSON format and structure
  - Grid dimensions (min 1x1, max 30x30)
  - Grid cells are integers
- Returns Server-Sent Events:
  ```
  event: progress
  data: {"current": 47, "total": 128}

  event: complete
  data: {"score": 0.875, "timeElapsedSeconds": 3847}

  event: error
  data: {"message": "Verification failed"}
  ```

**Error Handling:**
- Seed recovery failure: specific error message ("Could not verify submission. Task IDs don't match or file is corrupted.")
- Other failures: generic 500 error ("Verification failed")
- Grid validation handled entirely client-side

