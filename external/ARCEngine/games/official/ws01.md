# Author: Claude Opus 4
# Date: 2026-02-01
# PURPOSE: ws01 - World Shifter. The world moves around you, not the other way.
#          Large 50x50 mazes shift in opposite direction of input. Checkered rim cycles.
# SRP/DRY check: Pass
This was an incredibly bad implementation, and I'm not even sure why I'm keeping it.
import random

from arcengine import ARCBaseGame, BlockingMode, Camera, GameAction, InteractionMode, Level, Sprite

# Colors
BGD = 5   # background/void
WLC = 2   # wall color
PTC = -1  # path (transparent)
RA1 = 9   # rim A1 blue
RA2 = 10  # rim A2 light blue
RB1 = 11  # rim B1 yellow
RB2 = 12  # rim B2 orange
PLC = 8   # player center red
PLA = 0   # player arms white
EX1 = 14  # exit green
EX2 = 6   # exit pink


def gmz(w: int, h: int, sd: int = 0) -> list[list[int]]:
    rng = random.Random(sd)
    mz = []
    for y in range(h):
        rw = []
        for x in range(w):
            if x == 0 or x == w - 1 or y == 0 or y == h - 1:
                rw.append(WLC)
            elif x % 6 == 0 and y % 4 != 0:
                rw.append(WLC)
            elif y % 6 == 0 and x % 4 != 0:
                rw.append(WLC)
            elif rng.random() < 0.08:
                rw.append(WLC)
            else:
                rw.append(PTC)
        mz.append(rw)
    cx, cy = w // 2, h // 2
    for dy in range(-3, 4):
        for dx in range(-3, 4):
            nx, ny = cx + dx, cy + dy
            if 1 <= nx < w - 1 and 1 <= ny < h - 1:
                mz[ny][nx] = PTC
    return mz


def grm() -> list[list[int]]:
    sz = 64
    rw = 2
    px = []
    for y in range(sz):
        r = []
        for x in range(sz):
            inr = x < rw or x >= sz - rw or y < rw or y >= sz - rw
            if inr:
                r.append(RA1 if (x + y) % 2 == 0 else RA2)
            else:
                r.append(-1)
        px.append(r)
    return px


sprites = {
    "ply": Sprite(
        pixels=[
            [-1, PLA, -1],
            [PLA, PLC, PLA],
            [-1, PLA, -1],
        ],
        name="ply",
        blocking=BlockingMode.BOUNDING_BOX,
        interaction=InteractionMode.TANGIBLE,
        layer=10,
        tags=["ply"],
    ),
    "ext": Sprite(
        pixels=[
            [EX1, EX2, EX1],
            [EX2, EX1, EX2],
            [EX1, EX2, EX1],
        ],
        name="ext",
        blocking=BlockingMode.BOUNDING_BOX,
        interaction=InteractionMode.TANGIBLE,
        layer=5,
        tags=["mvb", "ext"],
    ),
    "rim": Sprite(
        pixels=grm(),
        name="rim",
        blocking=BlockingMode.NOT_BLOCKED,
        interaction=InteractionMode.INTANGIBLE,
        layer=20,
        tags=["rim"],
    ),
    "mz1": Sprite(
        pixels=gmz(50, 50, 1),
        name="mz1",
        blocking=BlockingMode.PIXEL_PERFECT,
        interaction=InteractionMode.TANGIBLE,
        layer=-1,
        tags=["mvb", "mze"],
    ),
    "mz2": Sprite(
        pixels=gmz(50, 50, 42),
        name="mz2",
        blocking=BlockingMode.PIXEL_PERFECT,
        interaction=InteractionMode.TANGIBLE,
        layer=-1,
        tags=["mvb", "mze"],
    ),
    "mz3": Sprite(
        pixels=gmz(50, 50, 123),
        name="mz3",
        blocking=BlockingMode.PIXEL_PERFECT,
        interaction=InteractionMode.TANGIBLE,
        layer=-1,
        tags=["mvb", "mze"],
    ),
    "mz4": Sprite(
        pixels=gmz(50, 50, 999),
        name="mz4",
        blocking=BlockingMode.PIXEL_PERFECT,
        interaction=InteractionMode.TANGIBLE,
        layer=-1,
        tags=["mvb", "mze"],
    ),
}

PLX = 31
PLY = 31

levels = [
    Level(
        sprites=[
            sprites["rim"].clone().set_position(0, 0),
            sprites["mz1"].clone().set_position(7, 7),
            sprites["ext"].clone().set_position(12, 12),
            sprites["ply"].clone().set_position(PLX, PLY),
        ],
        grid_size=(64, 64),
        data={"rph": 0},
    ),
    Level(
        sprites=[
            sprites["rim"].clone().set_position(0, 0),
            sprites["mz2"].clone().set_position(7, 7),
            sprites["ext"].clone().set_position(48, 48),
            sprites["ply"].clone().set_position(PLX, PLY),
        ],
        grid_size=(64, 64),
        data={"rph": 0},
    ),
    Level(
        sprites=[
            sprites["rim"].clone().set_position(0, 0),
            sprites["mz3"].clone().set_position(7, 7),
            sprites["ext"].clone().set_position(48, 12),
            sprites["ply"].clone().set_position(PLX, PLY),
        ],
        grid_size=(64, 64),
        data={"rph": 0},
    ),
    Level(
        sprites=[
            sprites["rim"].clone().set_position(0, 0),
            sprites["mz4"].clone().set_position(7, 7),
            sprites["ext"].clone().set_position(12, 48),
            sprites["ply"].clone().set_position(PLX, PLY),
        ],
        grid_size=(64, 64),
        data={"rph": 0},
    ),
]


class Ws01(ARCBaseGame):
    def __init__(self) -> None:
        super().__init__("ws01", levels, Camera(0, 0, 64, 64, BGD, BGD))

    def on_set_level(self, level: Level) -> None:
        self.ply = level.get_sprites_by_tag("ply")[0]
        self.mze = level.get_sprites_by_tag("mze")[0]
        self.rim = level.get_sprites_by_tag("rim")[0]
        self.rph = 0

    def step(self) -> None:
        dx, dy = 0, 0
        if self.action.id == GameAction.ACTION1:
            dy = 1
        elif self.action.id == GameAction.ACTION2:
            dy = -1
        elif self.action.id == GameAction.ACTION3:
            dx = 1
        elif self.action.id == GameAction.ACTION4:
            dx = -1

        if dx != 0 or dy != 0:
            if self.cmw(dx, dy):
                self.mvw(dx, dy)
                self.crm()

        if self.cex():
            if self.is_last_level():
                self.win()
            else:
                self.next_level()

        self.complete_action()

    def gpc(self) -> tuple[int, int]:
        return self.ply.x + 1, self.ply.y + 1

    def cmw(self, dx: int, dy: int) -> bool:
        pcx, pcy = self.gpc()
        nmx = self.mze.x + dx
        nmy = self.mze.y + dy
        lx = pcx - nmx
        ly = pcy - nmy
        if ly < 0 or ly >= len(self.mze.pixels):
            return False
        if lx < 0 or lx >= len(self.mze.pixels[0]):
            return False
        px = self.mze.pixels[ly][lx]
        return px != WLC

    def mvw(self, dx: int, dy: int) -> None:
        for spr in self.current_level.get_sprites_by_tag("mvb"):
            spr.move(dx, dy)

    def crm(self) -> None:
        self.rph = (self.rph + 1) % 4
        if self.rph == 0:
            c1, c2 = RA1, RA2
        elif self.rph == 1:
            c1, c2 = RB1, RB2
        elif self.rph == 2:
            c1, c2 = RA2, RA1
        else:
            c1, c2 = RB2, RB1
        sz = 64
        rw = 2
        for y in range(sz):
            for x in range(sz):
                inr = x < rw or x >= sz - rw or y < rw or y >= sz - rw
                if inr:
                    self.rim.pixels[y][x] = c1 if (x + y) % 2 == 0 else c2

    def cex(self) -> bool:
        exs = self.current_level.get_sprites_by_tag("ext")
        if not exs:
            return False
        ext = exs[0]
        pcx, pcy = self.gpc()
        ecx = ext.x + 1
        ecy = ext.y + 1
        return abs(pcx - ecx) <= 1 and abs(pcy - ecy) <= 1
