/**
 * feedbackService.ts
 * 
 * Service layer for feedback-related operations.
 * This service handles submitting and retrieving feedback for explanations.
 * 
 * @author Cascade
 */

import { repositoryService } from '../repositories/RepositoryService';
import { AppError } from '../middleware/errorHandler';
import { explanationService } from './explanationService';
import type { Feedback } from '../../shared/types';

// Use Omit to create a type for new feedback data, excluding fields generated by the database.
export type AddFeedbackData = Partial<Omit<Feedback, 'id' | 'createdAt'>> & { 
  feedbackType: Feedback['feedbackType'];
  referenceFeedbackId?: number; // Reference to another feedback entry (for voting on solutions)
};

export const feedbackService = {
  /**
   * Add feedback for an explanation.
   * 
   * @param data - The feedback data.
   * @returns Object with feedback ID and success message.
   * @throws AppError if feedback cannot be added.
   */
  async addFeedback(data: AddFeedbackData) {
    this.validateFeedback(data);
    const { puzzleId, explanationId, feedbackType, comment, userAgent, sessionId, referenceFeedbackId } = data;

    try {
      let finalPuzzleId = puzzleId;
      
      // If we have a referenceFeedbackId (for voting), we'll get the puzzleId from the referenced solution
      if (referenceFeedbackId) {
        // The repository will handle getting the puzzleId from the referenced solution
        // We don't need a finalPuzzleId here, as it will be retrieved in repository layer
      } else if (!finalPuzzleId && explanationId) {
        // If no puzzleId and we have an explanationId, get puzzle from the explanation
        const explanation = await repositoryService.explanations.getExplanationById(explanationId);
        if (!explanation) {
          throw new AppError('Explanation not found', 404, 'NOT_FOUND');
        }
        finalPuzzleId = explanation.puzzleId;
      }

      // Only check for puzzleId if we're not voting on a solution (which uses referenceFeedbackId)
      if (!finalPuzzleId && !referenceFeedbackId) {
        throw new AppError('Puzzle ID is required for feedback', 400, 'VALIDATION_ERROR');
      }

      const feedbackResult = await repositoryService.feedback.addFeedback({
        puzzleId: finalPuzzleId ?? null,
        explanationId: explanationId ?? null,
        feedbackType,
        comment: comment ?? null,
        userAgent,
        sessionId,
        referenceFeedbackId
      });

      const feedbackId = feedbackResult.feedback?.id;

      if (feedbackType === 'not_helpful' && explanationId) {
        try {
          const originalExplanation = await repositoryService.explanations.getExplanationById(explanationId);
          if (originalExplanation) {
            await explanationService.retryAnalysis(
              originalExplanation.puzzleId,
              originalExplanation.modelName || 'gpt-4',
              comment || ''
            );
          }
        } catch (retryError) {
          console.warn('Failed to trigger retry analysis:', retryError);
        }
      }

      return {
        success: true,
        message: feedbackType === 'not_helpful'
          ? 'Feedback recorded. Generating improved explanation...'
          : 'Feedback recorded successfully',
        feedbackId,
      };
    } catch (error) {
      throw new AppError(
        `Failed to add feedback: ${error instanceof Error ? error.message : 'Unknown error'}`,
        500,
        'DATABASE_ERROR'
      );
    }
  },
  
  /**
   * Validate feedback data before submitting.
   *
   * @param data - The feedback data to validate.
   * @throws AppError if validation fails.
   */
  validateFeedback(data: AddFeedbackData) {
    const { puzzleId, explanationId, feedbackType, comment } = data;
    const MINIMUM_COMMENT_LENGTH = 20;

    if (!puzzleId && !explanationId) {
      throw new AppError('Either puzzleId or explanationId is required', 400, 'VALIDATION_ERROR');
    }

    if (!feedbackType) {
      throw new AppError('Missing required field: feedbackType', 400, 'VALIDATION_ERROR');
    }

    const validFeedbackTypes: Feedback['feedbackType'][] = ['helpful', 'not_helpful', 'solution_explanation'];
    if (!validFeedbackTypes.includes(feedbackType)) {
      throw new AppError(`Invalid feedback type. Must be one of: ${validFeedbackTypes.join(', ')}`, 400, 'VALIDATION_ERROR');
    }

    if (feedbackType === 'not_helpful' && (!comment || comment.trim().length < MINIMUM_COMMENT_LENGTH)) {
      throw new AppError(
        `A meaningful comment of at least ${MINIMUM_COMMENT_LENGTH} characters is required for 'not_helpful' feedback`,
        400,
        'VALIDATION_ERROR'
      );
    }
  }
};
